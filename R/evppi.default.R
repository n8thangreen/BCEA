
#' evppi.default
#'
#' This function has been completely changed and restructured to make it possible to change regression method.
#' The method argument can now be given as a list. The first element element in the list is a vector giving the
#' regression method for the effects. The second gives the regression method for the costs. The `method' argument
#' can also be given as before which then uses the same regression method for all curves.
#' All other extra_args can be given as before. 'int.ord' can be updated using the list formulation above to give
#' the interactions for each different curve.
#' The formula argument for GAM can only be given once, either 'te()' or 's() + s()' as this is
#' for computational reasons rather than to aid fit.
#' You can still plot the INLA mesh elements but not output the meshes.
#' 
#' @param param_idx Parameter index
#' @param input 
#' @template args-he 
#' @param N Default NULL
#' @param plot TRUE or FALSE
#' @param residuals 
#' @param ... 
#'
#' @return
#' @export
#'
#' @examples
#' data(Vaccine)
#' he <- bcea(e,c)
#' 
evppi.default <- function(param_idx,
                          input,
                          he,
                          N = NULL,
                          plot = FALSE,
                          residuals = TRUE, ...) {
  
  if (is.null(colnames(input))) {
    colnames(input) <- paste0("theta", 1:dim(input)[2])
  }
  if (is.numeric(param_idx[1]) | is.integer(param_idx[1])) {
    params <- colnames(input)[param_idx]
  } else {
    params <- param_idx
    for (i in seq_along(params)) {
      param_idx[i] <- which(colnames(input) == params[i])
    }
    class(param_idx) <- "numeric"
  }
  if (is.null(N)) {
    N <- he$n_sim
  }
  
  robust <- NULL
  extra_args <- list(...)   #extra_args <- list()
  
  if (!exists("suppress.messages", where = extra_args)) {
    suppress.messages <- FALSE
  } else {
    suppress.messages <- extra_args$suppress.messages
  }
  
  if (!exists("select", where = extra_args) & N == he$n_sim) {
    extra_args$select <- 1:he$n_sim
  }
  if (!exists("select", where = extra_args) & N < he$n_sim) {
    extra_args$select <- sample(1:he$n_sim, size = N, replace = FALSE)
  }
  
  inputs <- data.frame(input)[extra_args$select, ]
  
  # Sets default for method of calculation
  # If number of params <=4, then use GAM, if not defaults to INLA/SPDE
  
  if (!exists("method", where = extra_args)) {
    
    extra_args$method <-
      if (length(param_idx) <= 4) {
        list(rep("GAM", he$n_comparators - 1),
             rep("GAM", he$n_comparators - 1))
      } else {
        list(rep("INLA", he$n_comparators - 1),
             rep("INLA", he$n_comparators - 1))
      }
  } else {
    
    if (inherits(extra_args$method, "list")) {
      
      #####TODO: this is a list tho...
      if (extra_args$method == "sad" | extra_args$method == "so") {
        extra_args$method <- extra_args$method
      } else {
        if (length(extra_args$method) > 1) {
          extra_args$method <- list(extra_args$method,
                                    extra_args$method)
        }
        if (length(extra_args$method) == 1) {
          
          extra_args$method <-
            list(rep(extra_args$method, he$n_comparators - 1),
                 rep(extra_args$method, he$n_comparators - 1))
        }
      }
    }
  }
  
  if (inherits(extra_args$method, "list")) {
    
    if (length(extra_args$method[[1]]) + length(extra_args$method[[2]]) != 2*(he$n_comparators - 1)) {
      stop(paste("The argument 'method' must be a list of length 2 with",
                 he$n_comparators - 1, "elements each."), call. = FALSE)
    }
  }
  
  
  # int.ord ----
  
  if (!exists("int.ord", where = extra_args)) {
    extra_args$int.ord <-
      list(rep(1, he$n_comparators - 1),
           rep(1, he$n_comparators - 1))
  }
  if (!inherits(extra_args$int.ord, "list")) {
    
    extra_args$int.ord <-
      list(
        rep(extra_args$int.ord[1], he$n_comparators - 1),
        rep(extra_args$int.ord[2], he$n_comparators - 1)
      )
  }
  
  if (!inherits(extra_args$int.ord, "list")) {
    if (extra_args$method == "sal" || extra_args$method == "sad") {
      method <- "Sadatsafavi et al"
      n.blocks <- NULL
      if (!exists("n_seps", where = extra_args)) {
        n_seps <- 1
      } else {
        n_seps <- extra_args$n_seps
      }
      if (length(params) == 1) {
        d <- he$n_comparators
        n <- he$n_sim
        w <- params
        param <- inputs[, w]
        o <- order(param)
        param <- param[o]
        nSegs <- matrix(1, d, d)
        nSegs[1, 2] <- n_seps
        nSegs[2, 1] <- n_seps
        res <- segPoints <- numeric()
        
        for (k in seq_along(he$k)) {
          nbs <- he$U[, k, ]
          nbs <- nbs[o, ]
          for (i in seq_len(d - 1)) {
            for (j in (i + 1):d) {
              cm <- cumsum(nbs[, i] - nbs[, j])/n
              if (nSegs[i, j] == 1) {
                l <- which.min(cm)
                u <- which.max(cm)
                if (cm[u] - max(cm[1], cm[n]) > min(cm[1],
                                                    cm[n]) - cm[l]) {
                  segPoint <- u
                }
                else {
                  segPoint <- l
                }
                if (segPoint > 1 && segPoint < n) {
                  segPoints <- c(segPoints, segPoint)
                }
              }
              if (nSegs[i, j] == 2) {
                distMaxMin <- 0
                distMinMax <- 0
                minL <- Inf
                maxL <- -Inf
                for (sims in seq_len(n)) {
                  if (cm[sims] > maxL) {
                    maxLP <- sims
                    maxL <- cm[sims]
                  }
                  else {
                    if (maxL - cm[sims] > distMaxMin) {
                      distMaxMin <- maxL - cm[sims]
                      segMaxMinL <- maxLP
                      segMaxMinR <- sims
                    }
                  }
                  if (cm[sims] < minL) {
                    minLP <- sims
                    minL <- cm[sims]
                  }
                  else {
                    if (cm[sims] - minL > distMinMax) {
                      distMinMax <- cm[sims] - minL
                      segMinMaxL <- minLP
                      segMinMaxR <- sims
                    }
                  }
                }
                siMaxMin <- cm[segMaxMinL] + distMaxMin + (cm[n] - cm[segMaxMinR])
                siMinMax <- -cm[segMaxMinL] + distMinMax - (cm[n] - cm[segMinMaxR])
                
                if (siMaxMin > siMinMax) {
                  segPoint <- c(segMaxMinL, segMaxMinR)
                }
                else {
                  segPoint <- c(segMinMaxL, segMinMaxR)
                }
                if (segPoint[1] > 1 && segPoint[1] < n) {
                  segPoints <- c(segPoints, segPoint[1])
                }
                if (segPoint[2] > 1 && segPoint[2] < n) {
                  segPoints <- c(segPoints, segPoint[2])
                }
              }
            }
          }
          if (length(segPoints) > 0) {
            segPoints2 <- unique(c(0, segPoints[order(segPoints)], n))
            res[k] <- 0
            for (j in seq_len(length(segPoints2) - 1)) {
              res[k] <-
                res[k] + max(colSums(
                  matrix(nbs[(1 + segPoints2[j]):segPoints2[j + 1], ],
                         ncol = d)))/n
            }
            res[k] <- res[k] - max(colMeans(nbs))
          }
          else {
            res[k] <- 0
          }
        }
      }
      if (length(params) > 1) {
        res <- list()
        for (lp in seq_along(params)) {
          d <- he$n_comparators
          n <- he$n_sim
          w <- params[lp]
          param <- inputs[, w]
          o <- order(param)
          param <- param[o]
          nSegs <- matrix(1, d, d)
          nSegs[1, 2] <- n_seps
          nSegs[2, 1] <- n_seps
          temp <- segPoints <- numeric()
          for (k in seq_along(he$k)) {
            nbs <- he$U[, k, ]
            nbs <- nbs[o, ]
            for (i in seq_len(d - 1)) {
              for (j in (i + 1):d) {
                cm <- cumsum(nbs[, i] - nbs[, j])/n
                if (nSegs[i, j] == 1) {
                  l <- which.min(cm)
                  u <- which.max(cm)
                  if (cm[u] - max(cm[1], cm[n]) > min(cm[1], cm[n]) - cm[l]) {
                    segPoint <- u
                  }
                  else {
                    segPoint <- l
                  }
                  if (segPoint > 1 && segPoint < n) {
                    segPoints <- c(segPoints, segPoint)
                  }
                }
                if (nSegs[i, j] == 2) {
                  distMaxMin <- 0
                  distMinMax <- 0
                  minL <- Inf
                  maxL <- -Inf
                  for (sims in seq_len(n)) {
                    if (cm[sims] > maxL) {
                      maxLP <- sims
                      maxL <- cm[sims]
                    }
                    else {
                      if (maxL - cm[sims] > distMaxMin) {
                        distMaxMin <- maxL - cm[sims]
                        segMaxMinL <- maxLP
                        segMaxMinR <- sims
                      }
                    }
                    if (cm[sims] < minL) {
                      minLP <- sims
                      minL <- cm[sims]
                    }
                    else {
                      if (cm[sims] - minL > distMinMax) {
                        distMinMax <- cm[sims] - minL
                        segMinMaxL <- minLP
                        segMinMaxR <- sims
                      }
                    }
                  }
                  siMaxMin <- cm[segMaxMinL] + distMaxMin + (cm[n] - cm[segMaxMinR])
                  siMinMax <- -cm[segMaxMinL] + distMinMax - (cm[n] - cm[segMinMaxR])
                  if (siMaxMin > siMinMax) {
                    segPoint <- c(segMaxMinL, segMaxMinR)
                  }
                  else {
                    segPoint <- c(segMinMaxL, segMinMaxR)
                  }
                  if (segPoint[1] > 1 && segPoint[1] < n) {
                    segPoints <- c(segPoints, segPoint[1])
                  }
                  if (segPoint[2] > 1 && segPoint[2] < n) {
                    segPoints <- c(segPoints, segPoint[2])
                  }
                }
              }
            }
            if (length(segPoints) > 0) {
              segPoints2 <- unique(c(0, segPoints[order(segPoints)],
                                     n))
              temp[k] <- 0
              for (j in seq_len(length(segPoints2) - 1)) {
                temp[k] <-
                  temp[k] + max(colSums(
                    matrix(nbs[(1 + segPoints2[j]):segPoints2[j + 1], ],
                           ncol = d)))/n
              }
              temp[k] <- temp[k] - max(colMeans(nbs))
            }
            else {
              temp[k] <- 0
            }
          }
          res[[lp]] <- temp
        }
        names(res) <- params
      }
      
      res <- list(evppi = res,
                  index = params,
                  params = params,
                  k = he$k,
                  evi = he$evi,
                  method = method)
    }
    if (extra_args$method == "so") {
      method <- "Strong & Oakley (univariate)"
      n_seps <- NULL
      if (!exists("n.blocks", where = extra_args)) {
        stop("Please specify the param_idx 'n.blocks' to use the Strong and Oakley univariate method", call. = FALSE)
      }
      else {
        n.blocks <- extra_args$n.blocks
      }
      S <- he$n_sim
      J <- S/extra_args$n.blocks
      check <- S%%extra_args$n.blocks
      if (check > 0) {
        stop("number of simulations/number of blocks must be an integer.
             Please select a different value for n.blocks \n", call. = FALSE)
      }
      D <- he$n_comparators
      if (length(param_idx) == 1) {
        sort.order <- order(inputs[, params])
        sort.U <- array(NA, dim(he$U))
        evpi <- res <- numeric()
        for (i in seq_along(he$k)) {
          evpi[i] <- he$evi[i]
          sort.U[, i, ] <- he$U[sort.order, i, ]
          U.array <- array(sort.U[, i, ],
                           dim = c(J, extra_args$n.blocks, D))
          mean.k <- apply(U.array, c(2, 3), mean)
          partial.info <- mean(apply(mean.k, 1, max))
          res[i] <- partial.info - max(apply(he$U[, i, ], 2, mean))
        }
      }
      if (length(param_idx) > 1) {
        res <- list()
        for (j in seq_along(param_idx)) {
          sort.order <- order(inputs[, params[j]])
          sort.U <- array(NA, dim(he$U))
          evpi <- evppi.temp <- numeric()
          for (i in seq_along(he$k)) {
            evpi[i] <- he$evi[i]
            sort.U[, i, ] <- he$U[sort.order, i, ]
            U.array <- array(sort.U[, i, ],
                             dim = c(J, n.blocks, D))
            mean.k <- apply(U.array, c(2, 3), mean)
            partial.info <- mean(apply(mean.k, 1, max))
            evppi.temp[i] <- partial.info - max(apply(he$U[, i, ], 2, mean))
          }
          res[[j]] <- evppi.temp
        }
        names(res) <- params
      }
      
      res <-
        list(evppi = res,
             index = params,
             params = params,
             k = he$k,
             evi = he$evi,
             method = method)
    }
  }
  
  if (inherits(extra_args$method, "list")) {
    time <- list()
    time[[1]] <- list()
    time[[2]] <- list()
    
    fit.full <- vector("list")
    fit.full[[1]] <- matrix(
      data = 0,
      nrow = length(extra_args$select),
      ncol = he$n_comparators)
    
    fit.full[[2]] <-
      matrix(data = 0,
             nrow = length(extra_args$select),
             ncol = he$n_comparators)
    
    for (k in 1:2) {
      for (l in seq_len(he$n_comparisons)) {
        x <-
          prep.x(he = he,
                 seq_rows = extra_args$select,
                 k = k,
                 l = l)
        
        method <- toupper(extra_args$method[[k]][l])
        
        if (method == "GAM" || method == "G") {
          method <- "GAM"
          mesh <- robust <- NULL
          if (!isTRUE(requireNamespace("mgcv", quietly = TRUE))) {
            stop("You need to install the package 'mgcv'. Please run in your R terminal:\n 
                 install.packages('mgcv')", call. = FALSE)
          }
          if (isTRUE(requireNamespace("mgcv", quietly = TRUE))) {
            if (!suppress.messages) {
              cat("\n")
              cat("Calculating fitted values for the GAM regression \n")
            }
            
            inp <- names(inputs)[param_idx]
            if (exists("formula", where = extra_args)) {
              form <- extra_args$formula
            } else {
              form <- paste("te(", paste(inp, ",", sep = "",
                                         collapse = ""), "bs='cr')")
            }
            fit <- fit.gam(parameter = param_idx,
                           inputs = inputs,
                           x = x,
                           form = form)
          }
        }
        if (method == "GP") {
          mesh <- robust <- NULL
          if (!suppress.messages) {
            cat("\n")
            cat("Calculating fitted values for the GP regression \n")
            # If the number of simulations to be used to estimate the
            # hyper-params is set then use that, else use N/2
          }
          if (!exists("n_sim", where = extra_args)) {
            n_sim <- N/2
          }
          else {
            n_sim <- extra_args$n_sim
          }
          fit <- fit.gp(parameter = param_idx,
                        inputs = inputs,
                        x = x,
                        n.sim = n_sim)
        }
        if (method == "INLA") {
          if (!isTRUE(requireNamespace("INLA", quietly = TRUE))) {
            stop("You need to install the packages 'INLA' and 'splancs'. Please run in your R terminal:\n 
                 install.packages('INLA', repos='http://www.math.ntnu.no/inla/R/stable')\n
                 and\n install.packages('splancs')", call. = FALSE)
          }
          if (!isTRUE(requireNamespace("ldr", quietly = TRUE))) {
            stop("You need to install the package 'ldr'. Please run in your R terminal:\n
                 install.packages('ldr')", call. = FALSE)
          }
          if (isTRUE(requireNamespace("ldr", quietly = TRUE))) {
            
            if (isTRUE(requireNamespace("INLA", quietly = TRUE))) {
              if (!is.element("INLA", (.packages()))) {
                attachNamespace("INLA")
              }
              if (length(param_idx) < 2) {
                stop("The INLA method can only be used with 2 or more params", call. = FALSE)
              }
              if (!suppress.messages) {
                cat("\n")
                cat("Finding projections \n")
              }
              projections <- make.proj(parameter = param_idx,
                                       inputs = inputs,
                                       x = x,
                                       k = k,
                                       l = l)
              data <- projections$data
              if (!suppress.messages) {
                cat("Determining Mesh \n")
              }
              if (!exists("cutoff", where = extra_args)) {
                cutoff <- 0.3
              }
              else {
                cutoff = extra_args$cutoff
              }
              if (!exists("convex.inner", where = extra_args)) {
                convex.inner <- -0.4
              }
              else {
                convex.inner <- extra_args$convex.inner
              }
              if (!exists("convex.outer", where = extra_args)) {
                convex.outer <- -0.7
              }
              else {
                convex.outer = extra_args$convex.outer
              }
              if (!exists("max.edge", where = extra_args)) {
                max.edge = 0.7
              }
              else {
                max.edge <- extra_args$max.edge
              }
              mesh <-
                make.mesh(
                  data = data,
                  convex.inner = convex.inner,
                  convex.outer = convex.outer,
                  cutoff = cutoff,
                  max.edge = max.edge
                )
              plot.mesh(mesh = mesh$mesh,
                        data = data,
                        plot = plot)
              if (!suppress.messages) {
                cat("Calculating fitted values for the GP regression using INLA/SPDE \n")
              }
              if (exists("h.value", where = extra_args)) {
                h.value <- extra_args$h.value
              }
              else {
                h.value <- 5e-05
              }
              if (exists("robust", where = extra_args)) {
                if (extra_args$robust) {
                  family <- "T"
                  robust <- TRUE
                }
                else {
                  family <- "gaussian"
                  robust <- FALSE
                }
              } else {
                family <- "gaussian"
                robust <- FALSE
              }
              if (exists("int.ord", where = extra_args)) {
                int.ord <- extra_args$int.ord[[k]][l]
              }
              else {
                int.ord <- 1
              }
              fit <- fit.inla(
                parameter = param_idx,
                inputs = inputs,
                x = x,
                mesh = mesh$mesh,
                data.scale = data,
                int.ord = int.ord,
                convex.inner = convex.inner,
                convex.outer = convex.outer,
                cutoff = cutoff,
                max.edge = max.edge,
                h.value = h.value,
                family = family
              )
            }
          }
        }
        fit.full[[k]][,l] <- fit$fitted
        
        # calculate time taken
        if (method == "INLA") {
          time. <- c(projections$time, mesh$time, fit$time)
          time. <- sum(time.)
          time[[k]][l] <- (time.)
        }
        else {
          time. <- fit$time
          time[[k]][l] <- time.
        }
      }
    }
    if (!suppress.messages) {cat("Calculating EVPPI \n")}
    
    comp <- compute.evppi(he = he, fit.full = fit.full)
    name <- prepare.output(parameters = params, inputs = inputs)
    time[[3]] <- comp$time
    names(time) <- c("Fitting for Effects",
                     "Fitting for Costs",
                     "Calculating EVPPI")
    names(extra_args$method) <- c("Methods for Effects", "Methods for Costs")
    
    if (residuals) {
      res <- list(
        evppi = comp$EVPPI,
        index = params,
        k = he$k,
        evi = he$evi,
        params = name,
        time = time,
        method = extra_args$method,
        fitted.costs = fit.full[[2]],
        fitted.effects = fit.full[[1]],
        select = extra_args$select)
    } else {
      res <- list(
        evppi = comp$EVPPI,
        index = params,
        k = he$k,
        evi = he$evi,
        params = name,
        time = time,
        method = extra_args$method)
    }
  }
  
  structure(res, class = "evppi")
}
